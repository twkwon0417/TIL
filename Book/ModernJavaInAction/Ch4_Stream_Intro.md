Stream
=======
- Data Collection 반복을 멋지게 처리하는 기능
> **장점**
> 1. **선언형**으로 코드를 구현할 수 있다.
> 2. filter, sorted, map ,collect와 같은 여러 빌딩 연산으로 연결해서 복잡한 데이터 처리 파이프 라인을 만들 수 있다.
> > 위 빌딩 연산자는 high-level building block으로 **특정 스레딩 모델에 제한되지 않고** 자유롭게 어떤 상황에서도 사용할 수 있다. -> 병렬처리 가능 & thread, lock을 걱정할 필요가 없다.

Stream deep dive
-----------------
**Stream** : 데이터 처리 연산을 지원 하도록 소스에서 추출된 연속된 요소
- 연속된 요소 : **계산이 주가 되는** 특정 요소 형식으로 이루어진 연속된 값을 집합
- 소스 : 스트림은 컬렉션, 배열 등의 데이터 제공 소스로부터 **데이터를 소비**한다. collection으로 stream을 만들면 stream의 요소는 collection과 **같은 순서**를 유지
- 데이터 처리 연산 : filter, map, reduce, find, match, sort등과 같은 연산이 존재한다. Stream연산을 순차적 || 병렬로 실행 가능
- Pipelining : **스트림 연산끼리 연결**해서 커다란 파이프 라인을 구성할 수 있도록 **스트림 자신을 반환**하는 연산이 다수 존재.
- 내부 반복 : 반복자를 사용하지 않고 내부에서 반복 됨
~~~ java
List<String> threeHighCaloricDishNames =
    menu.stream()
        .filter(dish -> dish.getCalories() > 300)
        .map(Dish::getName)
        .limit(3)
        .collect(toList());
~~~

Stream vs Collection
--------------------
- **공통점** : 연속된 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공한다.
- **차이점** : 데이터를 계산하는 시점
  > **Collection**
  > - 현재 자료구조가 포함하는 **모든 값을 메모리에 저장**하는 자료구조
  > - Collection의 모든 요소는 컬렉션에 **추가하기 전에 계산되어야 한다**.
  > - **적극적 생성** : 모든 값을 계산할 때까지 기다린다
  > 
  > **Stream**
  > - **요청할 때만 요소를 계산**하는 **고정**된 자료구조
  > - 스트림에 요소를 **추가**하거나 스트림에 요소를 **제거**할 수 **없다**. <br> 사용자가 요청하는 값만 **스트림에서 추출**
  > - **게으른 생성** : 필요할 때만 값을 계산한다.

외부 반복 & 내부 반복
-------------------
**외부 반복** : 사용자가 직접 요소를 반복 시킴
  - 명시적으로 컬렌션 항목을 하나씩 가지고와 처리해야 함
**내부 반복** : 반복을 알아서 처리함
  - 작업을 투명하게 병렬로 처리하거나 더 최적화된 다양한 순서로 처리할 수 있다. also 병렬성을 알아서 처리해줌! 
