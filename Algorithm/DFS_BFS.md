### <a href="http://boj.kr/a538e96669ff493783515183aa7af1f2" target="_blank"> BOJ 2178</a>
- BFS사용 : **visited[ny][nx] = visited[y][x] + 1 꼴이면 visited에 할당된 값은 시작점으로 부터 그 지점 까지의 최단 거리**
- BFS익숙해지자

### <a href="http://boj.kr/20c745bc0e204e5eba7682374a8c0aaa" target="_blank"> BOJ 2583</a>
- 차피 넓이 구하는 것이므로 임의로 좌표를 바꿔도 된다!
- **모눈종이에서는 i = a; i < b; i++**와 유사한 로직이 사용될거 같다.

### <a href="http://boj.kr/0ee12d28fe8d40d898d268e4dddbe3d2" target="_blank"> BOJ 1992</a>
- **분할정복** : 같은 로직이 반복되는 구조일때 재귀함수 쓰기

### <a href="http://boj.kr/92b313f064cf4b7e8d830bfe641cb339" target="_blank"> BOJ 3474</a>
- **수를 곱으로 표현 할때 빠르게 찾는 법**

### <a href="http://boj.kr/753737176c7c40bcab6c6ee1aede7ef1" target="_blank"> BOJ 2870</a>
- **Custom compare** : Big int쓰지 않고 string으로 숫자 비교하기

### <a href="http://boj.kr/44cd967ebbd649569575e07cbf757e6a" target="_blank"> BOJ 1436</a>
- **완전탐색** : 먼저 무식하게 풀 수 있는지 확인하고 무식 하게 풀기
- **str.find()** : **숫자를 string으로 바꿔서** find 함수 사용하기

### <a href="http://boj.kr/d47c7b0f3ea84d2894ea695b413be306" target="_blank"> BOJ 1068</a>
- **Edge case** 생각하기

### <a href="http://boj.kr/0f8ac21b53224ae298320f764e15d6b1" target="_blank"> BOJ 1325</a>
- **visited 배열 초기화**

### <a href="http://boj.kr/097f9325347243d1a6bfa9058bf56ca8" target="_blank"> BOJ 17298</a>
- **index 처리** : http://boj.kr/9270b97aae224481a0ad26b2bcff289a 이런 방법도 있다.
- **stack**의 응용
